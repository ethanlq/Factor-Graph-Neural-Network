=========================================================================
 MNC - Summary                                      6 December 1995 DJCM
=========================================================================

This document is a brief summary of a pipeline implementation of SMN
and NMN codes using a sequence of C programs. I have not set things up
so that the programs use stdin and stdout; rather, they read and write
files in a sequence of directories.

This set of programs can implement SMN and NMN codes over BSC's and
over Gaussian channels, and there are two ways of handling the BSC
case, namely one can set z=0 and have the noise probability vary from
bit to bit, or one can set z = Cn r and go the straightforward way.

I have not tested all the features of these programs, but I believe
that the features described below work correctly. 

The central programs that implement the channels are t2r and t2y.
These work in `block' mode even though there is no reason for them 
to do so. 

=========
NMN CODES
=========
BSC procedure 1:

 s2t source to transmitted : multiplies by G
 t2r adds BSC noise to t to give r.
 r2z multiplies by Cn
 zb2x reads in a z vector and sets constant bias; does belief net decoding,
	spitting out the decoded vector x of which the first k bits are s.

BSC procedure 2:

 s2t source to transmitted : multiplies by G
 t2r adds BSC noise to t to give r.
 r2b computes bias vector. The vector z is set to zero.
 zb2x reads in bias (b) vector for noise and sets bias for source bits
	to constant and does belief net decoding,
	spitting out the decoded vector x of which the first k bits are s.

Gaussian channel procedure:

 s2t source to transmitted : multiplies by G
 t2y adds gaussian noise.
 y2b takes the received signal y and deduces a bias vector. The vector z is set
	to zero.
 zb2x reads in a bias (b) vector and does belief net decoding,
        spitting out the decoded vector x of which the first k bits are s.

=========
SMN CODES
=========
BSC procedure 1:

 s2t source to transmitted : copies s to output, then multiplies by G too
 t2r adds BSC noise to t to give r.
 r2z multiplies by A
 zb2x reads in a z vector and sets constant bias; does belief net decoding,
	spitting out the decoded vector x.
 ???? first k bits of x must be subtracted from first k bits of r to give s.
	(??? indicates a program I have not written , because procedure 2
	works fine, thankyou)

BSC procedure 2:

 s2t source to transmitted : multiplies by G
 t2r adds BSC noise to t to give r.
 r2b computes bias vector. The vector z is set to zero.
 zb2x reads in bias (b) vector and does belief net decoding,
	spitting out the decoded vector x of which the first k bits are s.

Gaussian channel procedure:

 s2t source to transmitted : multiplies by G
 t2y adds gaussian noise.
 y2b takes the received signal y and deduces a bias vector. The vector z is set
	to zero.
 zb2x reads in a bias (b) vector and does belief net decoding,
        spitting out the decoded vector x of which the first k bits are s.

========== a little aside: =========================================
====================================================================
Not yet implemented:
d2s Radford's arithmetic coder
s2d and decoder. 

Auxiliary program:
makecode - 
	takes an Alist matrix and produces a G and a Cn by forcible inversion


Better way for the future:

(1) b should not be recorded (0...1) rather a, such that b=1/(1+e^{-a})
	would be best.
(2) change bnd so that both halves of the prior are received, not just one
	of them. Both of these changes will reduce the chance of rare
	round off problems (turning 0.99999 into 1.0, etc.)
====================================================================

----------------------
   EXAMPLES 
----------------------

All these examples use a tiny MN code, whose G matrix, A matrix and Cn 
matrix have been created from a previously generated A matrix
by the program makecode. The A matrix is 16 wide by 12 high, so that 
you can make an (n,k) = (12,4) NMN code from it, or you can make 
a (16,4) SMN code. 

Example 1a:
===========
 NMN transmission over BSC, using the z=0 route. Single block transmission.

s2t -sfile _s/4 -k 4 -n 12 -Gfile codes/12.4.3.111/G -tfile _t/12
t2r -tfile _t/12 -fn 0.1 -rfile _r/12 -n 12 -seed 234
r2b -rfile _r/12 -bfile _b/12 -n 12 -fn 0.1
zb2x -bfile _b/12 -bfs 0.25 -k 4 -n 12 -zfixed 0 -Afile codes/12.4.3.111/A -xfile _x/4 -xso 1

(the decoded message is in _x/4, and can be compared with _s/4)

What you should see in this example:

  bee% s2t -sfile _s/4 -k 4 -n 12 -Gfile codes/12.4.3.111/G -tfile _t/12
  s2t running
   exact number of blocks 1
  bee% t2r -tfile _t/12 -fn 0.1 -rfile _r/12 -n 12 -seed 234
  t2r running
  stream ended at bit 1 block 2
  Sent 12 bits and added 1 errors
  bee% r2b -rfile _r/12 -bfile _b/12 -n 12 -fn 0.1
  r2b running
  stream ended at bit 1 block 2
  bee% zb2x -bfile _b/12 -bfs 0.25 -k 4 -n 12 -zfixed 0 -Afile codes/12.4.3.111/A -xfile _x/4 -xso 1
  bias[5:16] will be read from _b/12
  zb2x running
  16 * 3 int matrix in
  12 * 4 int matrix in
  BND: viols   0  recon  10  its  3
  Warning: fread_dvector failed at component 5
   finished after 1 blocks

  (successful decodings always say `BND: viols   0')

Example 1b:
===========
 NMN transmission over BSC.
 Multiple transmissions, all in a single file. (3 blocks of 4 sparse bits)
s2t -sfile _s/12 -k 4 -n 12 -Gfile codes/12.4.3.111/G -tfile _t/12
t2r -tfile _t/12 -fn 0.1 -rfile _r/12 -n 12 -seed 234
r2b -rfile _r/12 -bfile _b/12 -n 12 -fn 0.1
zb2x -bfile _b/12 -bfs 0.25 -k 4 -n 12 -zfixed 0 -Afile codes/12.4.3.111/A -xfile _x/12 -xso 1

In this example, one of the three blocks is not decoded:

  bee% zb2x -bfile _b/12 -bfs 0.25 -k 4 -n 12 -zfixed 0 -Afile codes/12.4.3.111/A -xfile _x/12 -xso 1
  bias[5:16] will be read from _b/12
  zb2x running
  16 * 3 int matrix in
  12 * 4 int matrix in
  BND: viols   0  recon   8  its  3
  BND: viols   2  recon   6  its 21
  Decoding failure block 2
  BND: viols   0  recon   4  its  3
  Warning: fread_dvector failed at component 5
   finished after 3 blocks

Example 2a:
===========
 SMN transmission over BSC. [Note n and k switch meanings from line to line]

s2t -sfile _s/4 -k 4 -n 12 -Gfile codes/12.4.3.111/G -smn 1 -tfile _t/16
t2r -tfile _t/16 -fn 0.07 -rfile _r/16 -n 16 -seed 1224
r2b -rfile _r/16 -bfile _b/16 -n 16 -fn 0.08
zb2x -bfile _b/16 -k 4 -n 12 -zfixed 0 -Afile codes/12.4.3.111/A -xfile _x/4 -xso 1

Example 2b:
===========
 SMN - Multiple transmissions, all in a single file. 
	(four blocks of four dense bits)

s2t -sfile _s/16 -k 4 -n 12 -Gfile codes/12.4.3.111/G -smn 1 -tfile _t/16
t2r -tfile _t/16 -fn 0.07 -rfile _r/16 -n 16 -seed 1224
r2b -rfile _r/16 -bfile _b/16 -n 16 -fn 0.08
zb2x -bfile _b/16 -k 4 -n 12 -zfixed 0 -Afile codes/12.4.3.111/A -xfile _x/16 -xso 1

Example 3:
==========
 NMN - Gaussian channel (multiple transmissions)

s2t -sfile _s/16 -k 4 -n 12 -Gfile codes/12.4.3.111/G -tfile _t/12
t2y -tfile _t/12 -yfile _y/12 -gcx 1.7 -seed 322457 -n 12
y2b -yfile _y/12 -n 12 -bfile _b/12 -gcx 1.7
zb2x -bfs 0.5 -bfile _b/12 -zfixed 0 -k 4 -n 12 -Afile codes/12.4.3.111/A -xfile _x/16 -xso 1

Example 4:
==========
 SMN - Gaussian channel (multiple transmissions) [noisier channel, x=1.32]

s2t -sfile _s/16 -k 4 -n 12 -Gfile codes/12.4.3.111/G -smn 1 -tfile _t/16
t2y -tfile _t/16 -yfile _y/16 -gcx 1.32 -seed 322457 -n 16
y2b -yfile _y/16 -n 16 -bfile _b/16 -gcx 1.32
zb2x -bfile _b/16 -zfixed 0 -k 4 -n 12 -Afile codes/12.4.3.111/A -xfile _x/16gc -xso 1 -bndloops 100
diff _s/16 _x/16gc

----- end -
